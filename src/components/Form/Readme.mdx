---
name: Form
route: /components/Form
menu: Components
---

import { useState } from 'react';
import { Props, Playground } from 'docz';
import { Box } from '../Box';
import Input from './Input';
import TextareaMd from './TextareaMd';
import Checkbox from './Checkbox';
import Label from './Label';
import Calendar from './Calendar';
import Errors from './Errors';
import getSelectStyling from './selectStyling';
import Fields from './Fields';
import { DateUtils } from 'react-day-picker';
import Select from 'react-select';
import { ThemeConsumer } from 'styled-components';

# Form

Form exports both individual field components for all the major form field types,
as well as FieldsWrapper which takes a JSON config object and renders the whole set of fields, linked up to onChange handlers.

> _Note:_ FieldsWrapper does not render a `<form>` around the fields, that's up to you to add around it if needed.

## Input

<Props of={Input} />

<Playground>
  <Input
    name="first_name"
    label="Name"
    placeholder="First Name"
    onChange={e => console.log(e.target.name, e.target.value)}
  />
  <Input
    name="last_name"
    placeholder="Last Name"
    onChange={e => console.log(e.target.name, e.target.value)}
  />
</Playground>

## TextareaMd

`TextareaMd` is based on [Slate.js](https://docs.slatejs.org) heavily borrowing from [Outline's](http://getoutline.com) [Rich Markdown Editor](https://github.com/outline/rich-markdown-editor) with a lot of cusomizations.
It's pinned to slate.js v0.45 since slate's API changes quite rapidly at the moment and there are a lot of plugins availaabale for v0.44.

<Props of={TextareaMd} />

`TextareaMd` can also accept props for [Styled System: space, layout and flexbox](https://styled-system.com/api).

<Playground>
  {() => {
    const [value, setValue] = useState('Write something **bold**!');
    return (
      <TextareaMd
        label="Write something exciting"
        initialValue={value}
        onChange={setValue}
        onBlur={value => console.log('editor lost focus, last value:', value)}
        enableBlocks={['paragraph']}
        disableMarks={['deleted', 'code']}
        minHeight={150}
        maxHeight={400}
      />
    );
  }}
</Playground>

## Checkbox

Checkbox uses [rc-checkbox](https://github.com/react-component/checkbox) under the hood to handle events.

<Props of={Checkbox} />

<Playground>
  {() => {
    const [isVegan, setIsVegan] = useState(false);
    const [isDogPerson, setIsDogPerson] = useState(false);

    return (
      <>
          <Checkbox
            name="isVegan"
            checked={isVegan}
            onChange={e => setIsVegan(e.target.checked)}
            label={`I'm vegan`}
          />
          <Checkbox
            name="isDogPerson"
            checked={isDogPerson}
            onChange={e => setIsDogPerson(e.target.checked)}
            label={`I'm a dog person`}
          />
      </>
    );

}}

</Playground>

## Calendar

Calendar is based on [react-day-picker](http://react-day-picker.js.org/)

<Props of={Calendar} />

<Playground>
  {() => {
    const [selectedDays, setSelectedDays] = useState([]);
    const today = new Date()
    const availableDays = [
      new Date(today.getFullYear(), today.getDate() <28 ? today.getMonth() : today.getMonth() + 1, today.getDate() <28 ? today.getDate() + 1 : 1),
      new Date(today.getFullYear(), today.getDate() <26 ? today.getMonth() : today.getMonth() + 1, today.getDate() <28 ? today.getDate() + 3 : 3),
      new Date(today.getFullYear(), today.getDate() <24 ? today.getMonth() : today.getMonth() + 1, today.getDate() <28 ? today.getDate() + 5 : 5)
    ];

    const isSelected = (day) => {
      const selectedIndex = selectedDays.findIndex(selectedDay =>
        DateUtils.isSameDay(selectedDay, day)
      );
      return selectedIndex !== -1;
    };

    const handleDayClick = (day, {selected}) => {
      const updatedDays = [...selectedDays]
      const selectedIndex = selectedDays.findIndex(selectedDay => {
          return DateUtils.isSameDay(selectedDay, day)
      });
      if (selectedIndex > -1) {
        updatedDays.splice(selectedIndex, 1);
      } else {
        updatedDays.push(day);
      }
      setSelectedDays(updatedDays)
    }

    return (
      <Calendar
        placeholder="First Name"
        availableDays={availableDays}
        selectedDays={isSelected}
        onDayClick={handleDayClick}
        onChange={e => console.log(e.target.name, e.target.value)}
      />
    )

}}

</Playground>

## Select

HDS exports `getSelectStyling(theme)` to be used with [React Select](https://react-select.com)

Invoke `getSelectStyling` by passing it the current theme object, to receive context-accurate `theme` and `styling` objects for all ReactSelect components.

<Playground>
  <ThemeConsumer>
    {theme => {
      console.log(theme);
      const options = [
        { value: 'chocolate', label: 'Chocolate' },
        { value: 'strawberry', label: 'Strawberry' },
        { value: 'vanilla', label: 'Vanilla' },
      ];
      const selectStyling = getSelectStyling(theme);
      return (
        <>
          <Select options={options} {...selectStyling} />
          <Box padding="small" />
          <Select
            defaultValue={[options[2], options[3]]}
            isMulti
            name="food"
            options={options}
            {...selectStyling}
          />
        </>
      );
    }}
  </ThemeConsumer>
</Playground>

## Errors

<Props of={Errors} />
Props table might not render due to a [bug in docz](https://github.com/pedronauck/docz/issues/777)

<Playground>
  <Errors
    errors={[
      { msg: 'Custom errors from the backend' },
      new Error('And standard errors are supported'),
    ]}
  />
</Playground>

## Fields

<Props of={Fields} />

To render a complete form (without the form tag) use the `Fields` component.

Provide a config in object format like this:

```
fields = [
    {
      name: 'name',
      type: 'text',
      title: 'What is your name?',
      label: 'Name',
      required: true
    },
    {
      name: 'pitch',
      type: 'textarea',
      title:
        'Pitch me baby, one more time! You got 30 seconds or 100 words. Go.',
      label: 'Your Pitch',
      required: true
    },
    {
      name: 'ready',
      type: 'checkbox',
      label: `I'm ready`,
    },
    {
      name: 'favourite_icecream',
      type: 'select',
      label:
        `What's your favourite ice cream flavour?`,
      options: [
        { value: 'chocolate', label: 'Chocolate' },
        { value: 'strawberry', label: 'Strawberry' },
        { value: 'vanilla', label: 'Vanilla' },
      ]
    },
  ]
```

<Playground>
  {() => {
    const fieldsConfig = [
      {
        name: 'name',
        type: 'text',
        title: 'What is your name?',
        label: 'Name',
        required: true
      },
      {
        name: 'pitch',
        type: 'textarea',
        title:
          'Pitch me baby, one more time! You got 30 seconds or 100 words. Go.',
        label: 'Your Pitch',
        required: true
      },
      {
        name: 'ready',
        type: 'checkbox',
        label: `I'm ready`,
      },
      {
        name: 'favourite_icecream',
        type: 'select',
        label:
          `What's your favourite ice cream flavour?`,
        options: [
          { value: 'chocolate', label: 'Chocolate' },
          { value: 'strawberry', label: 'Strawberry' },
          { value: 'vanilla', label: 'Vanilla' },
        ]
      },
    ];

    const [formData, setFormData] = useState({});

    const handleChange = (fieldName, event) => {
      if (event && typeof event.preventDefault === 'function') {
        event.preventDefault();
      }

      if (event && event.target && event.target.value) {
        newFormData = {
          ...formData,
          [fieldName]: event.target.value || event.target.checked
        }
      }

      setFormData(newFormData)
    }

    const fieldsWithData = fieldsConfig.map((field) => {
        if (field.type === 'group') {
          let fieldsWithValue = { ...field };
          if (fieldsWithValue.list) {
            fieldsWithValue.list = fieldsWithValue.list.map((groupField) => {
              return { ...groupField, value: formData[groupField.name] };
            });
          }
          return fieldsWithValue;
        } else {
          return { ...field, value: formData[field.name] };
        }
      });

    return (
      <Fields fields={fieldsWithData} onChange={handleChange} />
    );

}}

</Playground>
